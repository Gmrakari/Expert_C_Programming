


segmentation faults are generated by an exception in the memory management unit
(the hardware responsible for supporting virtual memory).

The usual cause is dereferencing(looking at the contents of the address contained in)
a pointer with an uninitialized or illegal value.

int *p = 0;
*p = 17;	/* 	causes a segmentation fault */


Common immediate causes of segmentation fault:

dereferencing a pointer that doesn't contain a valid value

dereferencing a null pointer(often because the null pointer was returned from a system routine,and used without checking)

accessing something without the correct permission

running out of stack or heap space

The common programming errors that (eventually) lead to something that gives a segmentation fault,
in order of occurrence,are:

1.Bad point value errors:
	using a poionter before giving it a value,or passing a bad pointer to a library routine.

	The third Common way to generate a bad pointer is to access something after it has benn freed.

	You can amend your free statements to clear a pointer after freeing what it points to:

	free(q);p = NULL;

2.Overwritting errors:
	writing past either end of an array,writing past either end of a malloc'd block,or

	Overwriting some of the heap management structures

	p = malloc(256); p[-1] = 0;	p[256] = 0;

3.Free'ing error:
	freeing the same block twice,freeing something that you didn't malloc,freeing some memory that is

	still in use,or freeing an invalid pointer.

	A very common free error is to cdr down a linked list in a for(p = start; p; p = p->next) loop,then 

	in the loop body do a free(p).

	This leads a freed pointer to be dereferenced on the next loop iteration,with unpredictable results.

That show you:how to free elements in a linked list

struct node *p,*start,*tmp;
for(p = start;p;p = tmp;){
	tmp = p->next;
	free(p);
}


